# stm32的cube的配置

在外部中断中，STM32CubeMX其他的设置都是相同的，但是：

## 1.关于计数的配置

要打开**timers**(就是平时的配置下的**System Core**，同目录的)下的TIM2，设置：

1. 打开Clock Source 为Internal Clock（内部时钟）
2. prescaler(副钟)设置为，你Clock Configuration中的APB1 Peripheral Cloncks下的晶振（如果你按照我之前说的去找你的芯片的最大晶振，你只要写一个这个频率回车，就可以了）
3. 你想要的的延时时间-1
4. NVIC使能TIM2，应会打开相应的通道
   定时时间的计算：
   ![计时器时间计算公式](C:\Users\CJX\Desktop\笔记\STM32\图片\计时器时间计算公式.jpg)
   ![计时器时间的计算实例](C:\Users\CJX\Desktop\笔记\STM32\图片\计时器时间的计算实例.png)

# 代码层面

1. 重写void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)函数。

   ```c
   /* USER CODE BEGIN 0 */
   void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   {
   	if(htim->Instance == TIM2)
   	{
           //时间到达，要做的事情，如：
   		HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_0);
   	}
   }
   /* USER CODE END 0 */
   int main()
   ```

   

2. 打开中断。

   ```c
   /* USER CODE BEGIN 2 */
   	HAL_TIM_Base_Start_IT(&htim2);//这里是重点，下面的只是为了让你找到给你写的地方
     /* USER CODE END 2 */
   
     /* Infinite loop */
     /* USER CODE BEGIN WHILE */
     while (1)
   ```

3. 如果你不想在STM32CubeMX里修改时间，你可以打开tim.c中进行修改。

```c
void MX_TIM2_Init(void)
{
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 35999;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 999;//修改此处
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }

}
```

